<!DOCTYPE html>
<html lang="en">

<head>
    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/109/three.min.js"></script> -->
    <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.146.0/build/three.module.js",
                "OrbitControls": "https://unpkg.com/three@0.146.0/examples/jsm/controls/OrbitControls.js"
            }
        }
      </script>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        body {
            margin: 0px;
            overflow: hidden;
            
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
        }
    </style>

</head>
<body>
    <canvas id="fiveC"></canvas>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from "OrbitControls";

        //set canvas
        const canvas = document.getElementById("fiveC");
        var width = window.innerWidth;
        var height = window.innerHeight;
        canvas.setAttribute("width", width);
        canvas.setAttribute("height", height);

        const renderer = new THREE.WebGLRenderer({ canvas, alpha: true });

        //create Perspective Camera
        const fov = 75;
        const aspect = 2;
        const near = 0.1;
        //const far = 5;
        const far = 100;
        const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);

        camera.position.z = 5;

        const controls = new OrbitControls(camera, canvas);
        controls.target.set(0, 0, 0);
        controls.update();

        //create scene
        const scene = new THREE.Scene();

        //create BoxGeometry
        const boxWidth = 1;
        const boxHeight = 1;
        const boxDepth = 1;
        const geometry = new THREE.BoxGeometry(boxWidth, boxHeight, boxDepth);

        //const loader = new THREE.TextureLoader();
        const loader = new THREE.CubeTextureLoader;
        //const bgTexture = loader.load('BG4.png');
        const texture = loader.load([
            'BG4.png',
            'BG3.png',
            'BG2.png',
            'BG1.png',
            'BG5.png',
            'BG5.png'
        ])
        //scene.background = bgTexture;
        scene.background = texture;
        //console.log(loader.load('picture/Psis.png'))
        function makeIntance(_geometry, color, x, y) {
            //set meterial
            const meterial = new THREE.MeshBasicMaterial({ color });
            //const meterials = mapsResourse;
            //create Mesh Object
            const cube = new THREE.Mesh(_geometry, meterial);
            //const cube = new THREE.Mesh(_geometry, meterials);
            cube.position.x = x;
            cube.position.y = y;

            scene.add(cube);//add to scene
            return cube;

        }
        // const mapsResourse1 = [
        //     new THREE.MeshPhongMaterial({ map: loader.load('Psis.png') }),
        //     new THREE.MeshPhongMaterial({ map: loader.load('Msis.png') }),
        //     new THREE.MeshPhongMaterial({ map: loader.load('Hsis.png') }),
        //     new THREE.MeshPhongMaterial({ map: loader.load('Psis.png') }),
        //     new THREE.MeshPhongMaterial({ map: loader.load('Msis.png') }),
        //     new THREE.MeshPhongMaterial({ map: loader.load('Hsis.png') })
        // ]
        //
        // const mapsResourse2 = [
        //     new THREE.MeshPhongMaterial({ map: loader.load('Punc.png') }),
        //     new THREE.MeshPhongMaterial({ map: loader.load('Munc.png') }),
        //     new THREE.MeshPhongMaterial({ map: loader.load('Hunc.png') }),
        //     new THREE.MeshPhongMaterial({ map: loader.load('Punc.png') }),
        //     new THREE.MeshPhongMaterial({ map: loader.load('Munc.png') }),
        //     new THREE.MeshPhongMaterial({ map: loader.load('Hunc.png') })
        // ]
        //
        // const mapsResourse3 = [
        //     new THREE.MeshPhongMaterial({ map: loader.load('Pfat.png') }),
        //     new THREE.MeshPhongMaterial({ map: loader.load('Mfat.png') }),
        //     new THREE.MeshPhongMaterial({ map: loader.load('Hfat.png') }),
        //     new THREE.MeshPhongMaterial({ map: loader.load('Pfat.png') }),
        //     new THREE.MeshPhongMaterial({ map: loader.load('Mfat.png') }),
        //     new THREE.MeshPhongMaterial({ map: loader.load('Hfat.png') })
        //
        // ]
        //
        // const mapsResourse4 = [
        //     new THREE.MeshBasicMaterial({ map: loader.load('Pbro.png') }),
        //     new THREE.MeshBasicMaterial({ map: loader.load('Mbro.png') }),
        //     new THREE.MeshBasicMaterial({ map: loader.load('Hbro.png') }),
        //     new THREE.MeshBasicMaterial({ map: loader.load('Pbro.png') }),
        //     new THREE.MeshBasicMaterial({ map: loader.load('Mbro.png') }),
        //     new THREE.MeshBasicMaterial({ map: loader.load('Hbro.png') })
        // ]
        //
        // const mapsResourse5 = [
        //     new THREE.MeshBasicMaterial({ map: loader.load('Pgra.png') }),
        //     new THREE.MeshBasicMaterial({ map: loader.load('Mgra.png') }),
        //     new THREE.MeshBasicMaterial({ map: loader.load('Hgra.png') }),
        //     new THREE.MeshBasicMaterial({ map: loader.load('Pgra.png') }),
        //     new THREE.MeshBasicMaterial({ map: loader.load('Mgra.png') }),
        //     new THREE.MeshBasicMaterial({ map: loader.load('Hgra.png') })
        // ]

        const cubes = [
            makeIntance(geometry, 0x960018, -4, 0),
            makeIntance(geometry, 0x348EC7, -2, 1),
            makeIntance(geometry, 0xD4AF37, 0, 2),
            makeIntance(geometry, 0xC3552B, 2, 1),
            makeIntance(geometry, 0xA660A7, 4, 0)

            /*makeIntance(geometry, mapsResourse1, -4, 0),
            makeIntance(geometry, mapsResourse2, -2, 1),
            makeIntance(geometry, mapsResourse3, 0, 2),
            makeIntance(geometry, mapsResourse4, 2, 1),
            makeIntance(geometry, mapsResourse5, 4, 0)*/

        ];


        //set light
        const Lightcolor = 0xFFFFFF;
        const intensity = 3;
        const light = new THREE.DirectionalLight(Lightcolor, intensity);
        light.position.set(-1, 2, 4);
        scene.add(light);



        //render all those elements
        renderer.render(scene, camera);

        //rotate the cubes
        function render(time) {
            time *= 0.001;

            //set bgTexture repeat and offset prameter
            /*const canvasApect = canvas.clientWidth / canvas.clientHeight;
            const imageAspect = bgTexture.image ? bgTexture.image.width / bgTexture.image.height : 1; // else body
            const aspect = imageAspect / canvasApect;

            bgTexture.offset.x = aspect > 1 ? (1-1/aspect)/2 : 0;
            bgTexture.repeat.x = aspect > 1 ? 1/aspect: 1;

            bgTexture.offset.y = aspect > 1 ? 0 : (1-aspect)/2;
            bgTexture.repeat.y = aspect > 1 ? 1 : aspect;*/



            //rotate the cubes
            //cube.rotation.x = time;
            //cube.rotation.y = time;
            cubes.forEach(
                function (cube, ndx) {
                    const speed = 0.5 + ndx * 0.1;
                    const rot = time * speed;
                    cube.rotation.x = rot;
                    cube.rotation.y = rot;
                }
            )

            renderer.render(scene, camera);

            requestAnimationFrame(render);
        }
        requestAnimationFrame(render);


    </script>

</body>

</html>